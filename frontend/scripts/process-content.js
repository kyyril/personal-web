const fs = require("fs");
const path = require("path");
const matter = require("gray-matter");
const { remark } = require("remark");
const remarkGfm = require("remark-gfm");
const remarkRehype = require("remark-rehype");
const rehypeStringify = require("rehype-stringify");
const rehypeRaw = require("rehype-raw");
const remarkBreaks = require("remark-breaks");

// Create output directory if it doesn't exist
const outputDir = path.join(__dirname, "..", "src", "data");
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Process MDX files and create static data
const articlesDir = path.join(__dirname, "..", "content", "blog");

// Process markdown to HTML using remark/rehype
async function processMarkdownToHtml(content) {
  // Remove frontmatter
  const contentWithoutFrontmatter = content.replace(
    /^---\s*[\s\S]*?---\s*/,
    ""
  );

  // Helper to handle CJS/ESM module differences
  const usePlugin = (plugin) =>
    plugin && plugin.default ? plugin.default : plugin;

  const file = await remark()
    .use(usePlugin(remarkGfm))
    .use(usePlugin(remarkBreaks))
    .use(usePlugin(remarkRehype), { allowDangerousHtml: true })
    .use(usePlugin(rehypeRaw))
    .use(usePlugin(rehypeStringify))
    .process(contentWithoutFrontmatter);

  return String(file);
}

// Extract headings from content
function extractHeadings(content) {
  const headings = [];
  const lines = content.split("\n");

  for (const line of lines) {
    const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const text = headingMatch[2].trim();
      const id = text
        .toLowerCase()
        .replace(/[^\w\s-]/g, "")
        .replace(/\s+/g, "-");

      headings.push({
        id,
        text,
        level,
      });
    }
  }

  return headings;
}

// Process all articles
async function processAllArticles() {
  const articles = [];
  const categories = new Map();
  const tags = new Set();

  if (fs.existsSync(articlesDir)) {
    const files = fs
      .readdirSync(articlesDir)
      .filter((file) => file.endsWith(".mdx"));

    for (const file of files) {
      const filePath = path.join(articlesDir, file);
      const content = fs.readFileSync(filePath, "utf8");
      const { data, content: rawContent } = matter(content);

      // Skip drafts
      if (data.draft || data.published === false) {
        continue;
      }

      const slug = file.replace(/\.mdx$/, "");
      const headings = extractHeadings(rawContent);

      // Store raw MDX content instead of processed HTML
      const article = {
        slug,
        frontmatter: data,
        content: rawContent, // Store raw MDX content
        excerpt: rawContent
          .replace(/[#*`]/g, "")
          .replace(/\n+/g, " ")
          .trim()
          .slice(0, 160) + "...",
        headings,
      };

      articles.push(article);

      // Track categories
      const categoryCount = categories.get(data.category) || 0;
      categories.set(data.category, categoryCount + 1);

      // Track tags
      if (data.tags && Array.isArray(data.tags)) {
        data.tags.forEach((tag) => tags.add(tag));
      }
    }
  }

  return { articles, categories, tags };
}

// Main execution
(async function () {
  const { articles, categories, tags } = await processAllArticles();

  // Sort articles by date (newest first)
  articles.sort(
    (a, b) => new Date(b.frontmatter.date) - new Date(a.frontmatter.date)
  );

  // Create categories array
  const categoriesArray = Array.from(categories.entries()).map(
    ([name, count]) => ({
      name,
      slug: name.toLowerCase().replace(/\s+/g, "-"),
      description: `${name} related articles`,
      count,
    })
  );

  // Create data export
  const data = {
    articles,
    categories: categoriesArray,
    tags: Array.from(tags).sort(),
    lastUpdated: new Date().toISOString(),
  };

  // Write to TypeScript file
  const outputPath = path.join(outputDir, "blog-data.ts");
  const content = `// Auto-generated blog data
// This file is generated by scripts/process-content.js

export interface Article {
  slug: string;
  frontmatter: {
    title: string;
    description: string;
    date: string;
    category: string;
    tags: string[];
    author: string;
    readTime: string;
    coverImage?: string;
    published?: boolean;
    draft?: boolean;
  };
  content: string;
  excerpt: string;
  headings: {
    id: string;
    text: string;
    level: number;
  }[];
}

export interface Category {
  name: string;
  slug: string;
  description: string;
  count: number;
}

export const blogData = {
  articles: ${JSON.stringify(data.articles, null, 2)} as Article[],
  categories: ${JSON.stringify(data.categories, null, 2)} as Category[],
  tags: ${JSON.stringify(data.tags, null, 2)} as string[],
  lastUpdated: '${data.lastUpdated}',
} as const;

// Helper functions
export function getAllArticles(): Article[] {
  return blogData.articles;
}

export function getArticleBySlug(slug: string): Article | undefined {
  return blogData.articles.find(article => article.slug === slug);
}

export function getArticlesByCategory(categorySlug: string): Article[] {
  return blogData.articles.filter(article => 
    article.frontmatter.category.toLowerCase().replace(/\s+/g, '-') === categorySlug
  );
}

export function getAllCategories(): Category[] {
  return blogData.categories;
}

export function getRelatedArticles(currentArticle: Article, limit: number = 3): Article[] {
  return blogData.articles
    .filter(article => 
      article.slug !== currentArticle.slug &&
      (
        article.frontmatter.category === currentArticle.frontmatter.category ||
        article.frontmatter.tags.some(tag => currentArticle.frontmatter.tags.includes(tag))
      )
    )
    .slice(0, limit);
}

export function searchArticles(query: string): Article[] {
  const searchTerm = query.toLowerCase();
  return blogData.articles.filter(article =>
    article.frontmatter.title.toLowerCase().includes(searchTerm) ||
    article.frontmatter.description.toLowerCase().includes(searchTerm) ||
    article.frontmatter.tags.some(tag => tag.toLowerCase().includes(searchTerm))
  );
}

export function getRecentArticles(limit: number = 5): Article[] {
  return blogData.articles.slice(0, limit);
}
`;

  fs.writeFileSync(outputPath, content);

  console.log(`✅ Processed ${articles.length} articles`);
  console.log(`✅ Created ${categoriesArray.length} categories`);
  console.log(`✅ Found ${tags.size} unique tags`);
  console.log(`✅ Generated ${outputPath}`);
})();
