// Auto-generated blog data
// This file is generated by scripts/process-content.js

export interface Article {
  slug: string;
  frontmatter: {
    title: string;
    description: string;
    date: string;
    category: string;
    tags: string[];
    author: string;
    readTime: string;
    coverImage?: string;
    published?: boolean;
    draft?: boolean;
  };
  content: string;
  excerpt: string;
  headings: {
    id: string;
    text: string;
    level: number;
  }[];
}

export interface Category {
  name: string;
  slug: string;
  description: string;
  count: number;
}

export const blogData = {
  articles: [
  {
    "slug": "event-driven-rabbitmq-redis",
    "frontmatter": {
      "title": "The Distributed Nervous System: Building Reliable Event-Driven Architectures with RabbitMQ",
      "description": "A comprehensive guide to decoupling microservices. We explore the 'Dual Write' problem, implementing durable messaging patterns, and handling failure at scale.",
      "date": "2025-12-05",
      "category": "Backend Engineering",
      "tags": [
        "System Design",
        "RabbitMQ",
        "Event-Driven",
        "Microservices",
        "Reliability"
      ],
      "author": "Khairil Rahman",
      "readTime": "16 min read",
      "published": true
    },
    "content": "\r\nIn a monolithic application, consistent data is easy: you wrap everything in a single database transaction. `BEGIN`, Insert A, Insert B, `COMMIT`. Done.\r\n\r\nIn a **Distributed Microservices** world, this guarantee evaporates. You cannot effectively \"transaction\" across two different services with separate databases (Distributed Transactions/2PC are often too slow for web scale).\r\n\r\nThis article details how we transitioned from a brittle, synchronous HTTP-based system to a robust **Event-Driven Architecture** using RabbitMQ as the central nervous system.\r\n\r\n## The \"Dual Write\" Problem: A Recipe for Data Corruption\r\n\r\nThe most common mistake in microservices is the naive approach to coordinating actions.\r\n\r\n```typescript\r\n// âŒ The Naive Implementation (Synchronous Coupling)\r\nasync function completePurchase(user, amount) {\r\n  // 1. Save to Payment DB (Transaction Committed)\r\n  await paymentRepo.save({ user, amount });\r\n\r\n  // 2. Call Notification Service API\r\n  // ðŸ’¥ CRITICAL RISK: If this line throws (Timeout, 500 Error, Power Failure)\r\n  // The money is taken, but the user NEVER gets the email.\r\n  await axios.post(\"http://notification-service/email\", { user });\r\n}\r\n```\r\n\r\nThis leads to a system that is intimately coupled. If the Email Service goes down for maintenance, the **Purchase flow stops working**.\r\n\r\n### Visualizing the Risk\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant U as User\r\n    participant P as Payment Svc\r\n    participant DB as Payment DB\r\n    participant E as Email Svc\r\n\r\n    U->>P: Click Buy\r\n    P->>DB: INSERT Transaction\r\n    DB-->>P: OK (Committed)\r\n\r\n    P-x E: HTTP POST /send-email\r\n    Note right of P: NETWORK FAILURE / TIMEOUT\r\n\r\n    P-->>U: Error 500? Success?\r\n    Note right of U: User is confused. Money gone. No Email.\r\n```\r\n\r\n## The Solution: Durable Event-Driven Architecture\r\n\r\nWe decouple the intent (\"Payment Happened\") from the execution (\"Send Email\"). The Payment service's _only_ responsibility is to record the payment and tell the world what happened.\r\n\r\n### Architecture Overview\r\n\r\nWe utilize a **Publisher/Subscriber** model.\r\n\r\n```mermaid\r\nflowchart LR\r\n    subgraph \"Producer Domain\"\r\n        PaySvc[Payment Service]\r\n        PayDB[(Payment DB)]\r\n    end\r\n\r\n    subgraph \"Infrastructure\"\r\n        RMQ{RabbitMQ Broker}\r\n        Exchange((Topic Exchange))\r\n        Q1[Queue: notification.email]\r\n        Q2[Queue: course.unlock]\r\n    end\r\n\r\n    subgraph \"Consumer Domain\"\r\n        NotifSvc[Notification Service]\r\n        CourseSvc[Course Service]\r\n    end\r\n\r\n    PaySvc -->|1. Write| PayDB\r\n    PaySvc -->|2. Publish Event| Exchange\r\n\r\n    Exchange -.->|Routing: payment.*| Q1\r\n    Exchange -.->|Routing: payment.succeeded| Q2\r\n\r\n    Q1 -->|Consume| NotifSvc\r\n    Q2 -->|Consume| CourseSvc\r\n```\r\n\r\n### 1. Robust Publishing (Go)\r\n\r\nIn our Golang payment service, we treat the **Event** as a first-class citizen. We use **Publisher Confirms** to guarantee the broker received the message.\r\n\r\n```go\r\n// Go: Ensuring Durability\r\n// 1. Declare Durable Exchange (survives restarts)\r\nch.ExchangeDeclare(\"payment_events\", \"topic\", true, ...)\r\n\r\n// 2. Enable Publisher Confirms\r\nch.Confirm(false)\r\nconfirms := ch.NotifyPublish(make(chan amqp.Confirmation, 1))\r\n\r\n// 3. Publish Persistent Message\r\nch.Publish(\r\n    \"payment_events\",\r\n    \"payment.succeeded\",\r\n    false, false,\r\n    amqp.Publishing{\r\n        DeliveryMode: amqp.Persistent, // Writes to Disk\r\n        ContentType:  \"application/json\",\r\n        Body:         payload,\r\n    }\r\n)\r\n\r\n// 4. Wait for ACK from RabbitMQ\r\nif confirmed := <-confirms; !confirmed.Ack {\r\n    return fmt.Errorf(\"Critical: Message lost by broker\")\r\n}\r\n```\r\n\r\n## Advanced Patterns: Reliability at Scale\r\n\r\n### Fan-Out: The \"Open/Closed\" Principle\r\n\r\nOne of the greatest benefits of this architecture is extensibility.\r\n\r\nWhen a `payment.succeeded` event occurs:\r\n\r\n1.  **Notification Service** consumes it to send an email.\r\n2.  **Course Service** consumes it to unlock the video.\r\n3.  **Analytics** consumes it to update the revenue dashboard.\r\n\r\nIf we want to add a _Reward Service_ (Points system), we simply bind a new queue. **We do not touch the Payment Service code.**\r\n\r\n### Handling Failure: The Dead Letter Queue (DLQ) Strategy\r\n\r\nIn an HTTP world, an error crashes the request immediately. In an async world, a \"bad message\" (e.g., malformed JSON) can crash the consumer loop repeatedly, blocking all other messages.\r\n\r\nWe implement a rigorous **Retry & DLQ** lifecycle.\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> Processing\r\n\r\n    Processing --> Success : ACK\r\n    Processing --> TemporaryFail : Error (SMTP Timeout)\r\n\r\n    state TemporaryFail {\r\n       [*] --> Wait : Exponential Backoff\r\n       Wait --> Retry : Re-queue\r\n    }\r\n\r\n    Retry --> Processing\r\n\r\n    Processing --> PermanentFail : > 5 Retries\r\n    PermanentFail --> DLQ : Route to Dead Letter Exchange\r\n\r\n    state DLQ {\r\n        [*] --> ManualReview : Alert Developer\r\n        ManualReview --> Replay : Fix & Reprocess\r\n        ManualReview --> Drop : Discard\r\n    }\r\n```\r\n\r\n1.  **Transient Errors** (Network glitch): We NACK with `requeue=true` (or use a delayed exchange).\r\n2.  **Permanent Errors** (Buggy code): After 5 retries, RabbitMQ moves the message to `dlq.payment.notification`.\r\n3.  **Human Intervention**: A developer inspects the DLQ, patches the bug, and uses a \"Shovel\" script to replay the messages.\r\n\r\n## Conclusion\r\n\r\nMoving to an Event-Driven architecture introduces infrastructure complexity (managing a Broker), but it buys you **Resilience** and **Decoupling**.\r\n\r\n- **Reliability**: A downstream service outage never affects the core business transaction.\r\n- **Observability**: The queue depth becomes a metric for system load.\r\n- **Extensibility**: Features can be added by simply \"listening\" to the stream of events.\r\n\r\nFor a mission-critical platform handling real money and user access, this architectural rigor is not optionalâ€”it's essential.\r\n",
    "excerpt": "In a monolithic application, consistent data is easy: you wrap everything in a single database transaction. BEGIN, Insert A, Insert B, COMMIT. Done.\r \r In a Dis...",
    "headings": []
  },
  {
    "slug": "beyond-serverless-vps-deployment",
    "frontmatter": {
      "title": "Escaping the Cloud Bill: A DevOps Guide to Production-Ready VPS Hosting",
      "description": "Serverless is great, until it gets expensive. Learn how to architect a robust, self-healing microservices infrastructure on a standard Linux VPS using Docker.",
      "date": "2025-11-18",
      "category": "DevOps",
      "tags": [
        "Docker",
        "Nginx",
        "Infrastructure",
        "Self-Hosting",
        "Cost Optimization"
      ],
      "author": "Khairil Rahman",
      "readTime": "10 min read",
      "published": true
    },
    "content": "\r\nThe modern developer stack often defaults to Vercel, Netlify, or AWS Lambda. It's easy, fast, and freeâ€”initially. But as side projects grow into real businesses, the unpredictable pricing and \"cold start\" latency can become major bottlenecks.\r\n\r\nThere is an alternative that is often feared but incredibly powerful: **Self-Hosting on a VPS (Virtual Private Server)**.\r\n\r\nIn this guide, I'll walk you through how to take a $5/month Linux server and turn it into a production-grade container orchestration platform that rivals managed services.\r\n\r\n## The Myth of \"Serverless is Simpler\"\r\n\r\nServerless abstracts away servers, but it introduces new complexity:\r\n- **Vendor Lock-in**: Your code often relies on specific cloud triggers.\r\n- **Cold Boot**: The 500ms-2s delay when a function wakes up.\r\n- **Connection Limits**: Serverless functions often exhaust database connection pools.\r\n\r\nOn a VPS, your application is always alive, always warm, and you have Full Control.\r\n\r\n## Architecture: The \"Fortress\" Approach\r\n\r\nThe goal is to securely host multiple Docker containers (App, Database, Cache) on one machine without exposing them to the world.\r\n\r\nWe use a **Reverse Proxy** pattern.\r\n\r\n```mermaid\r\ngraph TD\r\n    Internet((Public Internet))\r\n    \r\n    subgraph \"Your VPS (The Fortress)\"\r\n        Nginx[Nginx Gateway]\r\n        \r\n        subgraph \"Internal Network (Hidden)\"\r\n            App[Node.js App]\r\n            API[Go API]\r\n            DB[(Database)]\r\n            Cache[(Redis)]\r\n        end\r\n    end\r\n    \r\n    Internet -->|HTTPS : 443| Nginx\r\n    Nginx -->|port:3000| App\r\n    Nginx -->|port:8080| API\r\n    \r\n    App <--> DB\r\n    API <--> DB\r\n    App <--> Cache\r\n```\r\n\r\n### 1. The Gateway (Nginx)\r\n\r\nInstead of exposing your Node.js app directly on port 3000 (which is insecure), we place Nginx at the front. Nginx handles:\r\n- **SSL Termination**: Automating HTTPS certificates with Let's Encrypt.\r\n- **Security Headers**: Block XSS and clickjacking attacks before they reach your app.\r\n- **Load Balancing**: Routing `/api` to your backend and everything else to your frontend.\r\n\r\n### 2. Container Orchestration (Docker Compose)\r\n\r\nYou don't need Kubernetes. For most applications, **Docker Compose** is enough. It allows you to define your infrastructure as code.\r\n\r\nThe secret to stability is **Resource Limiting**.\r\n\r\n```yaml\r\n  database:\r\n    image: postgres:15\r\n    restart: always\r\n    deploy:\r\n      resources:\r\n        limits:\r\n          cpus: '0.50' # Never let DB eat more than 50% CPU\r\n          memory: 512M\r\n```\r\n\r\nWithout this, a memory leak in one app could crash your database. With limits, Docker kills just the offending container, and `restart: always` brings it back in seconds.\r\n\r\n## Database Management: The Scariest Part\r\n\r\nThe main reason people avoid VPS is database management. \"What if I lose data?\"\r\n\r\nThe solution is **Volume Mapping** + **Automated Backups**.\r\n1.  Map your database data to the host: `- ./data/postgres:/var/lib/postgresql/data`.\r\n2.  Run a simple cron job that dumps this folder to an S3 bucket or Google Drive every night.\r\n\r\nThis gives you the reliability of a managed database without the $150/month price tag.\r\n\r\n## Automating Deployments (CI/CD)\r\n\r\nDeploying to a VPS doesn't mean dragging and dropping files via FTP like it's 1999. You can use **GitHub Actions**.\r\n\r\n1.  **Build**: GitHub builds your Docker image and pushes it to a private registry.\r\n2.  **Trigger**: GitHub SSHs into your VPS.\r\n3.  **Update**: It runs `docker compose pull && docker compose up -d`.\r\n\r\nThis \"Rolling Update\" strategy ensures your uptime remains 99.9% even during deployments.\r\n\r\n## Conclusion\r\n\r\nSelf-hosting forces you to understand Linux, networking, and security. It's a steeper learning curve than `vercel deploy`.\r\n\r\nBut the reward is a system that costs a fixed amount ($5-20/mo), never sleeps, has zero cold starts, and is completely under your control. For many growing startups and serious projects, that trade-off is worth making.\r\n",
    "excerpt": "The modern developer stack often defaults to Vercel, Netlify, or AWS Lambda. It's easy, fast, and freeâ€”initially. But as side projects grow into real businesses...",
    "headings": []
  },
  {
    "slug": "getting-started-nextjs",
    "frontmatter": {
      "title": "Getting Started with Next.js 15 App Router",
      "description": "Complete tutorial for starting development with Next.js 15 and the new App Router features",
      "date": "2025-11-07",
      "category": "framework",
      "tags": [
        "nextjs",
        "app-router",
        "tutorial",
        "react"
      ],
      "author": "Khairil Rahman",
      "readTime": "8 min read",
      "published": true
    },
    "content": "\r\nNext.js 15 introduces the powerful **App Router** for building modern web applications. In this comprehensive guide, we'll explore the fundamentals of using Next.js 15 with App Router.\r\n\r\n## What is App Router?\r\n\r\nApp Router is a revolutionary routing system in Next.js that provides:\r\n\r\n- **Server Components** - Build components that run on the server\r\n- **Streaming** - Progressive rendering for better performance\r\n- **Built-in optimization** - Automatic code splitting and optimization\r\n- **Enhanced developer experience** - Better DX with file-system based routing\r\n\r\n## Setting Up Your First Project\r\n\r\nTo create a new Next.js 15 project with App Router, run:\r\n\r\n```bash\r\nnpx create-next-app@latest my-app --typescript --tailwind --eslint\r\n```\r\n\r\n### Project Directory Structure\r\n\r\nApp Router uses a file-system based routing approach:\r\n\r\n```\r\napp/\r\nâ”œâ”€â”€ layout.tsx\r\nâ”œâ”€â”€ page.tsx\r\nâ”œâ”€â”€ blog/\r\nâ”‚   â”œâ”€â”€ page.tsx\r\nâ”‚   â””â”€â”€ [slug]/\r\nâ”‚       â””â”€â”€ page.tsx\r\nâ”œâ”€â”€ about/\r\nâ”‚   â””â”€â”€ page.tsx\r\nâ””â”€â”€ globals.css\r\n```\r\n\r\n## Creating Your First Component\r\n\r\nLet's build a simple component to understand the basics:\r\n\r\n```tsx\r\n// components/HelloWorld.tsx\r\nexport default function HelloWorld() {\r\n  return (\r\n    <div className=\"text-center py-8\">\r\n      <h1 className=\"text-3xl font-bold text-blue-600\">\r\n        Hello World with Next.js 15!\r\n      </h1>\r\n      <p className=\"mt-4 text-gray-600\">\r\n        Building modern web applications has never been easier.\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## Key App Router Features\r\n\r\n### Server Components\r\n\r\nServer Components provide several advantages:\r\n\r\n- **Reduced bundle size** - Code only runs on the server\r\n- **Better performance** - Faster initial page loads\r\n- **Automatic code splitting** - Optimized loading automatically\r\n- **SEO benefits** - Better search engine optimization\r\n\r\n### Streaming\r\n\r\nStreaming enhances user experience with:\r\n\r\n- **Progressive rendering** - Show content as it becomes available\r\n- **Selective hydration** - Hydrate only interactive parts\r\n- **Faster perceived performance** - Users see content sooner\r\n- **Better error boundaries** - Handle errors gracefully\r\n\r\n### Layout System\r\n\r\nApp Router introduces a powerful layout system:\r\n\r\n- **Root layout** - Shared layout for entire application\r\n- **Nested layouts** - Layouts can be nested for different sections\r\n- **Loading states** - Built-in loading UI support\r\n- **Error handling** - Granular error boundaries\r\n\r\n## Conclusion\r\n\r\nNext.js 15 with App Router represents a significant advancement in React development. It provides an exceptional developer experience while delivering superior performance and user experience.\r\n\r\nThe combination of Server Components, Streaming, and the new Layout System makes Next.js 15 App Router the ideal choice for building modern web applications in 2025 and beyond.\r\n\r\nStay tuned for upcoming articles where we'll dive deeper into advanced App Router features and best practices!\r\n",
    "excerpt": "Next.js 15 introduces the powerful App Router for building modern web applications. In this comprehensive guide, we'll explore the fundamentals of using Next.js...",
    "headings": []
  },
  {
    "slug": "state-management-recursive-data",
    "frontmatter": {
      "title": "Mastering Complex State: Managing Recursive Data Structures in React with Zustand",
      "description": "A comprehensive engineering guide to handling deeply nested, recursive state without performance pitfalls. We explore immutable update patterns, selector optimizations, and optimistic UI strategies.",
      "date": "2025-11-02",
      "category": "Frontend Architecture",
      "tags": [
        "React",
        "Zustand",
        "Performance",
        "State Management",
        "Data Structures"
      ],
      "author": "Khairil Rahman",
      "readTime": "14 min read",
      "published": true
    },
    "content": "\r\nIn modern frontend engineering, we often face data structures that defy simple \"flat\" state management. Consider a Course Builder, a File System explorer, or an Organization Chart. These are **Recursive** and **Deeply Nested**.\r\n\r\nManaging a structure like `Course > Modules > Lessons > Videos > Quizzes > Questions` (5+ levels deep) exposes the cracks in standard React patterns.\r\n\r\n- **Context API** triggers generic re-renders unless you split contexts aggressively.\r\n- **Redux** adds significant boilerplate for deeply nested updates.\r\n- **Prop Drilling** is unmaintainable.\r\n\r\nThis article details a battle-tested approach using **Zustand** to manage complex hierarchical data with high performance and maintainability.\r\n\r\n## The Performance Bottleneck\r\n\r\nThe core problem isn't storing the data; it's **updating** it. In React, immutability is king. To update a single question at Level 5, you technically need to clone every parent object up to the root.\r\n\r\n```javascript\r\n// The \"Spread Operator Hell\"\r\nsetCourse(prev => ({\r\n  ...prev,\r\n  modules: prev.modules.map(mod =>\r\n    mod.id === targetModId ? {\r\n      ...mod,\r\n      lessons: mod.lessons.map(lesson =>\r\n        // ... and so on for 3 more levels ...\r\n      )\r\n    } : mod\r\n  )\r\n}))\r\n```\r\n\r\nThis is not just ugly; it's dangerous. One mistake breaks object reference equality, causing your `React.memo` components to re-render unnecessarily.\r\n\r\n## Solution 1: Surgical Immutability (Without Immer)\r\n\r\nWhile libraries like Immer are great, understanding how to perform surgical updates manually gives you better control over memory allocation.\r\n\r\nWe implemented a pattern we call **\"Path-Based Updates\"**. By identifying the \"Path\" to the node (ModuleID, LessonID, AssessmentID), we can traverse and update only the necessary branch.\r\n\r\n### The \"Find and Map\" Pattern\r\n\r\nInstead of blind mapping, we check IDs at every level. If an ID doesn't match, we return the _original reference_.\r\n\r\n```typescript\r\n// A scalable update pattern for nested lists\r\nconst updateNestedItem = (items, targetId, updateFn) => {\r\n  return items.map((item) => {\r\n    if (item.id !== targetId) return item; // Return exact reference (cheap)\r\n    return updateFn(item); // Create new reference (mutation)\r\n  });\r\n};\r\n```\r\n\r\nThis ensures that if you update a Question in \"Lesson A\", the component for \"Lesson B\" sees literally the same prop object and skips re-rendering entirely.\r\n\r\n## Solution 2: Atomic Selectors with Zustand\r\n\r\nZustand shines because it holds state _outside_ the React render cycle. Components only \"subscribe\" to what they return from the selector.\r\n\r\nFor a deeply nested component, do **not** select the whole store.\r\n\r\n```typescript\r\n// âŒ BAD: Re-renders on ANY change in the app\r\nconst { course } = useStore();\r\nconst lesson = course.modules[0].lessons[0];\r\n\r\n// âœ… GOOD: Re-renders ONLY when this specific title changes\r\nconst lessonTitle = useStore(\r\n  (state) =>\r\n    state.course.modules\r\n      .find((m) => m.id === mId)\r\n      ?.lessons.find((l) => l.id === lId)?.title\r\n);\r\n```\r\n\r\nBy passing primitive values (strings, numbers) or stable objects out of the selector, strict-equality checks prevents wasted renders.\r\n\r\n## Solution 3: Handling Drag-and-Drop (DnD)\r\n\r\nReordering items in a tree is notoriously tricky. You have to move Item X from Parent A to Parent B while maintaining index positions.\r\n\r\nWe separate the **Visual State** from the **Server State**.\r\n\r\n### Optimistic Reordering\r\n\r\nWhen the user drops an item:\r\n\r\n1.  **Immediate Mutation**: We run the move logic locally in Zustand. The UI snaps instantly.\r\n2.  **Debounced Sync**: We don't send an API call for every pixel dragged. We wait for the `onDragEnd` event.\r\n3.  **Background Save**: We send the new generic `order` array (e.g., `['id-1', 'id-3', 'id-2']`) to the backend.\r\n\r\n```typescript\r\nmoveLesson: (fromModuleId, toModuleId, lessonId, newIndex) =>\r\n  set((state) => {\r\n    // 1. Remove from Source\r\n    const sourceModule = state.course.modules.find(\r\n      (m) => m.id === fromModuleId\r\n    );\r\n    const lesson = sourceModule.lessons.find((l) => l.id === lessonId);\r\n    const newSourceLessons = sourceModule.lessons.filter(\r\n      (l) => l.id !== lessonId\r\n    );\r\n\r\n    // 2. Insert into Target\r\n    const targetModule = state.course.modules.find((m) => m.id === toModuleId);\r\n    const newTargetLessons = [...targetModule.lessons];\r\n    newTargetLessons.splice(newIndex, 0, lesson);\r\n\r\n    // 3. Reconstruct State (Only touching affected modules)\r\n    // ...\r\n  });\r\n```\r\n\r\n## Resilience: Drafts and Rollbacks\r\n\r\nComplex forms crash. Users lose internet.\r\n\r\nTo make the system robust, we persist the \"Draft State\" in `localStorage`.\r\n\r\n- **Auto-Save**: Every 30 seconds, the Zustand state is serialized to local storage.\r\n- **Hydration**: On reload, we check if a local draft is newer than the server data. If so, we prompt: _\"Resume your unsaved changes?\"_\r\n\r\n## Conclusion\r\n\r\nManaging recursive state requires a shift in mindset from \"Global Updates\" to \"Targeted Operations.\"\r\n\r\nBy combining **Zustand's atomic selectors**, **Manual Reference Preservation**, and **Optimistic UI patterns**, you can build complex editors often reserved for desktop apps directly in the browser. The key is to respect the Render Cycleâ€”touched data changes, everything else stays static.\r\n",
    "excerpt": "In modern frontend engineering, we often face data structures that defy simple \"flat\" state management. Consider a Course Builder, a File System explorer, or an...",
    "headings": []
  },
  {
    "slug": "polyglot-microservices-go-nodejs",
    "frontmatter": {
      "title": "The Best of Both Worlds: Architecting a Polyglot System with Go and Node.js",
      "description": "Why we abandoned the 'One Language' rule and paired Node.js's velocity with Go's raw performance to build a scalable EdTech platform.",
      "date": "2024-12-26",
      "category": "System Architecture",
      "tags": [
        "Microservices",
        "Go",
        "Node.js",
        "System Design",
        "Backend"
      ],
      "author": "Khairil Rahman",
      "readTime": "15 min read",
      "published": true
    },
    "content": "\r\nThe \"Golden Rule\" of early startup engineering is often: **Stick to one stack.** If you write the frontend in TypeScript, write the backend in TypeScript. It minimizes context switching and simplifies hiring.\r\n\r\nBut as our platform grew from a simple CRUD app to a high-volume payment processor, we hit a ceiling. The same dynamic features that made Node.js perfect for our CMS were becoming a liability for our financial ledger.\r\n\r\nThis article details our journey into a **Polyglot Microservices Architecture**, specifically how and why we integrated **Go (Golang)** alongside our existing **Node.js** services.\r\n\r\n## The Tale of Two Domains\r\n\r\nTo understand the decision, we must analyze the two distinct \"Physics\" of our application.\r\n\r\n### Domain A: Content & Users (The \"Soft\" Domain)\r\n- **Characteristics**: Highly relational data, deeply nested JSON structures, frequent schema changes (Marketing wants a new field yesterday), IO-bound.\r\n- **The Best Tool**: **Node.js + NestJS/Express**.\r\n- **Reasoning**: JavaScript's object flexibility and TypeORM's powerful relational mapping make handling complex course hierarchies (Course > Module > Lesson > Video > Quiz) a breeze.\r\n\r\n### Domain B: Payments & Transactions (The \"Hard\" Domain)\r\n- **Characteristics**: Immutable data, high concurrency (webhooks), CPU-bound (cryptographic signatures), zero tolerance for type errors.\r\n- **The Best Tool**: **Go (Golang)**.\r\n- **Reasoning**: Go's compile-time strictness and Goroutine model allow us to handle thousands of concurrent payment webhooks on a $5 server without blocking.\r\n\r\n## Architectural Deep Dive\r\n\r\nWe didn't just spin up a separate server; we architected a symbiotic system where the two languages cover each other's blind spots.\r\n\r\n```mermaid\r\ngraph TD\r\n    User((User))\r\n    Gateway[Nginx Gateway]\r\n    \r\n    subgraph \"Node.js Cluster\"\r\n        Auth[Auth Service]\r\n        Course[Course Builder]\r\n    end\r\n    \r\n    subgraph \"Go Cluster\"\r\n        Pay[Payment Engine]\r\n    end\r\n    \r\n    MQ{RabbitMQ}\r\n    \r\n    User -->|Content Requests| Gateway --> Auth & Course\r\n    User -->|Checkout| Gateway --> Pay\r\n    \r\n    Course -- \"Assign Course\" --> MQ\r\n    Pay -- \"Payment Success\" --> MQ\r\n    \r\n    MQ -- Sync --> Auth\r\n```\r\n\r\n### 1. Performance: Event Loop vs. Goroutines\r\n\r\nNode.js runs on a **Single Thread**. If a webhook requires complex SHA-256 signature verification (common in Fintech), it blocks the Event Loop. If you receive 1000 webhooks at once, the 1000th request might time out before processing starts.\r\n\r\nGo, conversely, spawns a lightweight **Goroutine** for every request.\r\n```go\r\n// Go handles 10,000 requests like a breeze\r\nfunc HandleWebhook(c *fiber.Ctx) error {\r\n    go func() {\r\n        // Complex calculation happens here, off the main path\r\n        VerifySignature(c.Body())\r\n    }()\r\n    return c.SendStatus(202) // Instant response\r\n}\r\n```\r\n\r\n### 2. Type Safety: The Trillion Dollar Mistake\r\n\r\nIn Node.js/TypeScript, types are erased at runtime. You might define an interface `PaymentAmount`, but if the API sends a string `\"100.00\"` instead of a number `100`, your math might break silently (`\"100.00\" + 20` = `\"100.0020\"`).\r\n\r\nIn Go, this is impossible.\r\n```go\r\ntype Payment struct {\r\n    Amount int64 `json:\"amount\"` // Strict definition\r\n}\r\n// If JSON is string, Unmarshal fails instantly.\r\n// Zero ambiguity.\r\n```\r\nThis strictness is annoying for a CMS, but **vital** for a Ledger.\r\n\r\n## The Glue: Shared Contracts\r\n\r\nThe danger of Polyglot is \"Contract Drift\"â€”Node expects `userId` (camelCase) but Go sends `user_id` (snake_case).\r\n\r\nWe solved this using **Shared JSON Schemas**.\r\n1.  We define the Source of Truth in a `.proto` or JsonSchema file.\r\n2.  **Generate TypeScript interfaces**: `npm run gen:types`\r\n3.  **Generate Go Structs**: `go generate ./...`\r\n\r\nThis ensures that `PaymentSucceededEvent` looks identical in both codebases.\r\n\r\n## Deployment Strategy: Docker Multistage\r\n\r\nDeploying two languages requires a unified pipeline. We use Docker to abstract the underlying runtime.\r\n\r\n**Node.js Dockerfile:**\r\n- Heavy (`node_modules`).\r\n- Optimized with multi-stage build to remove devDependencies.\r\n- Image Size: ~150MB.\r\n\r\n**Go Dockerfile:**\r\n- Statically compiled binary.\r\n- Built `FROM golang:alpine AS builder`.\r\n- Copied to `FROM scratch`.\r\n- Image Size: **~15MB**.\r\n\r\nThe Go containers are so small and fast to start (millis) that we can autoscale them aggressively during flash sales.\r\n\r\n## The Trade-off: Development Friction\r\n\r\nIt's not all sunshine. Introducing a second language has costs:\r\n1.  **Context Switching**: A developer working on the Course API (JS) feels \"slowed down\" when switching to the Payment API (Go) due to the verbose syntax.\r\n2.  **Tooling Duplication**: We need two linters, two test runners, and two sets of CI pipelines.\r\n3.  **Hiring**: Finding \"Full Stack\" developers is hard. Finding \"Node + Go\" Polyglots is harder.\r\n\r\n## Conclusion: Use the Right Tool for the Right Job\r\n\r\nWe found the sweet spot:\r\n- Use **Node.js** where you need **Velocity** and **Flexibility**.\r\n- Use **Go** where you need **Stability** and **Throughput**.\r\n\r\nFor our EdTech platform, splitting the \"Business Logic\" from the \"Money Logic\" wasn't just an optimization; it was the key to sleeping soundly at night, knowing that while a UI bug might hide a button, it would never lose a dollar.\r\n",
    "excerpt": "The \"Golden Rule\" of early startup engineering is often: Stick to one stack. If you write the frontend in TypeScript, write the backend in TypeScript. It minimi...",
    "headings": []
  },
  {
    "slug": "enhanced-mdx-features",
    "frontmatter": {
      "title": "Enhanced MDX Features: Rich Content Rendering",
      "description": "Exploring advanced MDX rendering capabilities with quotes, images, callouts, and interactive elements",
      "date": "2024-11-08",
      "category": "Development",
      "tags": [
        "MDX",
        "React",
        "Frontend",
        "Content"
      ],
      "author": "Khairil Rahman",
      "readTime": "8 min read",
      "published": true
    },
    "content": "\r\nWelcome to this comprehensive showcase of enhanced MDX rendering capabilities. This article demonstrates various rich content elements that make your blog posts more engaging and visually appealing.\r\n\r\nMDX (Markdown + JSX) is a powerful format that combines the simplicity of Markdown with the power of React components. This comprehensive guide showcases various rich content elements you can use in your blog posts.\r\n\r\n## Blockquotes with Author Attribution\r\n\r\nBlockquotes can now include author attribution. Simply add `-- Author Name` at the end of your blockquote:\r\n\r\n> The best way to predict the future is to create it.\r\n> -- Peter Drucker\r\n\r\n> Innovation distinguishes between a leader and a follower.\r\n> -- Steve Jobs\r\n\r\n## Enhanced Images with Captions\r\n\r\nImages now support captions using the `title` attribute in markdown:\r\n\r\n![Beautiful sunset over mountains](https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=400&fit=crop \"A stunning sunset view over rugged mountain peaks\")\r\n\r\n## Callout Boxes\r\n\r\nUse callout boxes to highlight important information:\r\n\r\n### Info Callout\r\n\r\n<div class=\"callout-info\">\r\n  Info: This is useful for general information that readers should pay attention\r\n  to.\r\n</div>\r\n\r\n### Warning Callout\r\n\r\n<div class=\"callout-warning\">\r\n  Warning: Be careful with this important warning message.\r\n</div>\r\n\r\n### Success Callout\r\n\r\n<div class=\"callout-success\">\r\n  Success: Great job! This indicates successful completion of a task.\r\n</div>\r\n\r\n### Error Callout\r\n\r\n<div class=\"callout-error\">\r\n  Error: Something went wrong. Check your code and try again.\r\n</div>\r\n\r\n## Collapsible Sections\r\n\r\nCreate expandable content sections for better organization:\r\n\r\n<details>\r\n<summary>What is MDX?</summary>\r\n\r\nMDX is a format that allows you to write JSX in your Markdown documents. It combines the simplicity of Markdown with the power of React components, enabling you to create rich, interactive content.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>How does it work?</summary>\r\n\r\nMDX files are processed by remark and rehype plugins that transform the content into React components. This allows you to use custom components directly in your markdown while maintaining readability.\r\n\r\n</details>\r\n\r\n## Text Formatting\r\n\r\n### Highlighted Text\r\n\r\nUse the `<mark>` tag to highlight important text:\r\n\r\nThe `<mark>` element represents text which is <mark>marked or highlighted</mark> for reference or notation purposes.\r\n\r\n### Code Blocks with Copy Functionality\r\n\r\nCode blocks now include syntax highlighting and copy-to-clipboard functionality:\r\n\r\n```javascript\r\nfunction greetUser(name) {\r\n  console.log(`Hello, ${name}! Welcome to enhanced MDX rendering.`);\r\n  return `Greeting sent to ${name}`;\r\n}\r\n\r\n// Usage\r\ngreetUser(\"Developer\");\r\n```\r\n\r\n```python\r\ndef calculate_fibonacci(n):\r\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\r\n    if n <= 1:\r\n        return n\r\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\r\n\r\n# Example usage\r\nprint(calculate_fibonacci(10))  ## Output: 55\r\n```\r\n\r\n### Advanced Lists\r\n\r\n- **Feature 1:** Enhanced list styling with custom bullets\r\n- **Feature 2:** Better spacing and typography\r\n- **Feature 3:** Improved readability across devices\r\n\r\n## Mathematical Expressions\r\n\r\nWhile not natively supported in this renderer, you can use inline code for simple expressions: `E = mcÂ²` or `aÂ² + bÂ² = cÂ²`.\r\n\r\n## Mermaid Diagrams\r\n\r\nMermaid diagrams are now supported! You can create various types of diagrams directly in your MDX content using the `mermaid` language syntax.\r\n\r\n### Flowchart Example\r\n\r\n```mermaid\r\nflowchart TD\r\n    A[Start] --> B{Is it working?}\r\n    B -->|Yes| C[Great!]\r\n    B -->|No| D[Debug]\r\n    D --> B\r\n    C --> E[End]\r\n```\r\n\r\n### Sequence Diagram Example\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User\r\n    participant Frontend\r\n    participant API\r\n    participant Database\r\n    \r\n    User->>Frontend: Submit form\r\n    Frontend->>API: POST /api/users\r\n    API->>Database: Insert user data\r\n    Database-->>API: Confirmation\r\n    API-->>Frontend: 201 Created\r\n    Frontend-->>User: Success message\r\n```\r\n\r\n### Class Diagram Example\r\n\r\n```mermaid\r\nclassDiagram\r\n    class User {\r\n        +string id\r\n        +string email\r\n        +string name\r\n        +login() bool\r\n        +logout() void\r\n    }\r\n    \r\n    class Post {\r\n        +string id\r\n        +string title\r\n        +string content\r\n        +datetime createdAt\r\n        +publish() void\r\n    }\r\n```\r\n\r\n### State Diagram Example\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> Idle\r\n    Idle --> Loading: Start request\r\n    Loading --> Success: Data received\r\n    Loading --> Error: Request failed\r\n    Success --> [*]\r\n    Error --> Idle: Retry\r\n```\r\n\r\n## Tables with Enhanced Styling\r\n\r\n| Feature     | Status   | Description                    |\r\n| ----------- | -------- | ------------------------------ |\r\n| Blockquotes | Enhanced | Now support author attribution |\r\n| Images      | Enhanced | Added caption support          |\r\n| Callouts    | New      | Multiple types available       |\r\n| Collapsible | New      | Expandable content sections    |\r\n| Highlights  | New      | Text highlighting support      |\r\n\r\n## Conclusion\r\n\r\nThese enhanced MDX features provide a rich set of tools for creating engaging and interactive blog content. From author-attributed quotes to collapsible sections, callout boxes, and now **Mermaid diagrams**, your articles can now be more visually appealing and user-friendly.\r\n\r\nMermaid diagrams support various types including:\r\n- Flowcharts for process visualization\r\n- Sequence diagrams for interaction flows\r\n- Class diagrams for system architecture\r\n- State diagrams for state management\r\n- And many more diagram types!\r\n\r\n> The future of web content is interactive and engaging. With enhanced MDX rendering, we're just scratching the surface of what's possible.\r\n> -- Modern Web Developer\r\n\r\n_This article showcases the enhanced MDX renderer capabilities, including the new Mermaid diagram support. Try creating your own content with these features!_\r\n",
    "excerpt": "Welcome to this comprehensive showcase of enhanced MDX rendering capabilities. This article demonstrates various rich content elements that make your blog posts...",
    "headings": []
  }
] as Article[],
  categories: [
  {
    "name": "DevOps",
    "slug": "devops",
    "description": "DevOps related articles",
    "count": 1
  },
  {
    "name": "Development",
    "slug": "development",
    "description": "Development related articles",
    "count": 1
  },
  {
    "name": "Backend Engineering",
    "slug": "backend-engineering",
    "description": "Backend Engineering related articles",
    "count": 1
  },
  {
    "name": "framework",
    "slug": "framework",
    "description": "framework related articles",
    "count": 1
  },
  {
    "name": "System Architecture",
    "slug": "system-architecture",
    "description": "System Architecture related articles",
    "count": 1
  },
  {
    "name": "Frontend Architecture",
    "slug": "frontend-architecture",
    "description": "Frontend Architecture related articles",
    "count": 1
  }
] as Category[],
  tags: [
  "Backend",
  "Content",
  "Cost Optimization",
  "Data Structures",
  "Docker",
  "Event-Driven",
  "Frontend",
  "Go",
  "Infrastructure",
  "MDX",
  "Microservices",
  "Nginx",
  "Node.js",
  "Performance",
  "RabbitMQ",
  "React",
  "Reliability",
  "Self-Hosting",
  "State Management",
  "System Design",
  "Zustand",
  "app-router",
  "nextjs",
  "react",
  "tutorial"
] as string[],
  lastUpdated: '2025-12-26T01:07:28.795Z',
} as const;

// Helper functions
export function getAllArticles(): Article[] {
  return blogData.articles;
}

export function getArticleBySlug(slug: string): Article | undefined {
  return blogData.articles.find(article => article.slug === slug);
}

export function getArticlesByCategory(categorySlug: string): Article[] {
  return blogData.articles.filter(article => 
    article.frontmatter.category.toLowerCase().replace(/s+/g, '-') === categorySlug
  );
}

export function getAllCategories(): Category[] {
  return blogData.categories;
}

export function getRelatedArticles(currentArticle: Article, limit: number = 3): Article[] {
  return blogData.articles
    .filter(article => 
      article.slug !== currentArticle.slug &&
      (
        article.frontmatter.category === currentArticle.frontmatter.category ||
        article.frontmatter.tags.some(tag => currentArticle.frontmatter.tags.includes(tag))
      )
    )
    .slice(0, limit);
}

export function searchArticles(query: string): Article[] {
  const searchTerm = query.toLowerCase();
  return blogData.articles.filter(article =>
    article.frontmatter.title.toLowerCase().includes(searchTerm) ||
    article.frontmatter.description.toLowerCase().includes(searchTerm) ||
    article.frontmatter.tags.some(tag => tag.toLowerCase().includes(searchTerm))
  );
}

export function getRecentArticles(limit: number = 5): Article[] {
  return blogData.articles.slice(0, limit);
}
