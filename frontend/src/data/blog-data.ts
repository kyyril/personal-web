// Auto-generated blog data
// This file is generated by scripts/process-content.js

export interface Article {
  slug: string;
  frontmatter: {
    title: string;
    description: string;
    date: string;
    category: string;
    tags: string[];
    author: string;
    readTime: string;
    coverImage?: string;
    published?: boolean;
    draft?: boolean;
  };
  content: string;
  excerpt: string;
  headings: {
    id: string;
    text: string;
    level: number;
  }[];
}

export interface Category {
  name: string;
  slug: string;
  description: string;
  count: number;
}

export const blogData = {
  articles: [
  {
    "slug": "event-driven-rabbitmq-redis",
    "frontmatter": {
      "title": "The Distributed Nervous System: Building Reliable Event-Driven Architectures with RabbitMQ",
      "description": "A comprehensive guide to decoupling microservices. We explore the 'Dual Write' problem, implementing durable messaging patterns, and handling failure at scale.",
      "date": "2025-12-05",
      "category": "Backend Engineering",
      "tags": [
        "System Design",
        "RabbitMQ",
        "Event-Driven",
        "Microservices",
        "Reliability"
      ],
      "author": "Khairil Rahman",
      "readTime": "16 min read",
      "published": true
    },
    "content": "\r\nIn a monolithic application, consistent data is easy: you wrap everything in a single database transaction. `BEGIN`, Insert A, Insert B, `COMMIT`. Done.\r\n\r\nIn a **Distributed Microservices** world, this guarantee evaporates. You cannot effectively \"transaction\" across two different services with separate databases (Distributed Transactions/2PC are often too slow for web scale).\r\n\r\nThis article details how we transitioned from a brittle, synchronous HTTP-based system to a robust **Event-Driven Architecture** using RabbitMQ as the central nervous system.\r\n\r\n## The \"Dual Write\" Problem: A Recipe for Data Corruption\r\n\r\nThe most common mistake in microservices is the naive approach to coordinating actions.\r\n\r\n```typescript\r\n// The Naive Implementation (Synchronous Coupling)\r\nasync function completePurchase(user, amount) {\r\n  // 1. Save to Payment DB (Transaction Committed)\r\n  await paymentRepo.save({ user, amount });\r\n\r\n  // 2. Call Notification Service API\r\n  // CRITICAL RISK: If this line throws (Timeout, 500 Error, Power Failure)\r\n  // The money is taken, but the user NEVER gets the email.\r\n  await axios.post(\"http://notification-service/email\", { user });\r\n}\r\n```\r\n\r\nThis leads to a system that is intimately coupled. If the Email Service goes down for maintenance, the **Purchase flow stops working**.\r\n\r\n### Visualizing the Risk\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant U as User\r\n    participant P as Payment Svc\r\n    participant DB as Payment DB\r\n    participant E as Email Svc\r\n\r\n    U->>P: Click Buy\r\n    P->>DB: INSERT Transaction\r\n    DB-->>P: OK (Committed)\r\n\r\n    P-x E: HTTP POST /send-email\r\n    Note right of P: NETWORK FAILURE / TIMEOUT\r\n\r\n    P-->>U: Error 500? Success?\r\n    Note right of U: User is confused. Money gone. No Email.\r\n```\r\n\r\n## The Solution: Durable Event-Driven Architecture\r\n\r\nWe decouple the intent (\"Payment Happened\") from the execution (\"Send Email\"). The Payment service's _only_ responsibility is to record the payment and tell the world what happened.\r\n\r\n### Architecture Overview\r\n\r\nWe utilize a **Publisher/Subscriber** model.\r\n\r\n```mermaid\r\nflowchart LR\r\n    subgraph \"Producer Domain\"\r\n        PaySvc[Payment Service]\r\n        PayDB[(Payment DB)]\r\n    end\r\n\r\n    subgraph \"Infrastructure\"\r\n        RMQ{RabbitMQ Broker}\r\n        Exchange((Topic Exchange))\r\n        Q1[Queue: notification.email]\r\n        Q2[Queue: course.unlock]\r\n    end\r\n\r\n    subgraph \"Consumer Domain\"\r\n        NotifSvc[Notification Service]\r\n        CourseSvc[Course Service]\r\n    end\r\n\r\n    PaySvc -->|1. Write| PayDB\r\n    PaySvc -->|2. Publish Event| Exchange\r\n\r\n    Exchange -.->|Routing: payment.*| Q1\r\n    Exchange -.->|Routing: payment.succeeded| Q2\r\n\r\n    Q1 -->|Consume| NotifSvc\r\n    Q2 -->|Consume| CourseSvc\r\n```\r\n\r\n### 1. Robust Publishing (Go)\r\n\r\nIn our Golang payment service, we treat the **Event** as a first-class citizen. We use **Publisher Confirms** to guarantee the broker received the message.\r\n\r\n```go\r\n// Go: Ensuring Durability\r\n// 1. Declare Durable Exchange (survives restarts)\r\nch.ExchangeDeclare(\"payment_events\", \"topic\", true, ...)\r\n\r\n// 2. Enable Publisher Confirms\r\nch.Confirm(false)\r\nconfirms := ch.NotifyPublish(make(chan amqp.Confirmation, 1))\r\n\r\n// 3. Publish Persistent Message\r\nch.Publish(\r\n    \"payment_events\",\r\n    \"payment.succeeded\",\r\n    false, false,\r\n    amqp.Publishing{\r\n        DeliveryMode: amqp.Persistent, // Writes to Disk\r\n        ContentType:  \"application/json\",\r\n        Body:         payload,\r\n    }\r\n)\r\n\r\n// 4. Wait for ACK from RabbitMQ\r\nif confirmed := <-confirms; !confirmed.Ack {\r\n    return fmt.Errorf(\"Critical: Message lost by broker\")\r\n}\r\n```\r\n\r\n## Advanced Patterns: Reliability at Scale\r\n\r\n### Fan-Out: The \"Open/Closed\" Principle\r\n\r\nOne of the greatest benefits of this architecture is extensibility.\r\n\r\nWhen a `payment.succeeded` event occurs:\r\n\r\n1.  **Notification Service** consumes it to send an email.\r\n2.  **Course Service** consumes it to unlock the video.\r\n3.  **Analytics** consumes it to update the revenue dashboard.\r\n\r\nIf we want to add a _Reward Service_ (Points system), we simply bind a new queue. **We do not touch the Payment Service code.**\r\n\r\n### Handling Failure: The Dead Letter Queue (DLQ) Strategy\r\n\r\nIn an HTTP world, an error crashes the request immediately. In an async world, a \"bad message\" (e.g., malformed JSON) can crash the consumer loop repeatedly, blocking all other messages.\r\n\r\nWe implement a rigorous **Retry & DLQ** lifecycle.\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> Processing\r\n\r\n    Processing --> Success : ACK\r\n    Processing --> TemporaryFail : Error (SMTP Timeout)\r\n\r\n    state TemporaryFail {\r\n       [*] --> Wait : Exponential Backoff\r\n       Wait --> Retry : Re-queue\r\n    }\r\n\r\n    Retry --> Processing\r\n\r\n    Processing --> PermanentFail : > 5 Retries\r\n    PermanentFail --> DLQ : Route to Dead Letter Exchange\r\n\r\n    state DLQ {\r\n        [*] --> ManualReview : Alert Developer\r\n        ManualReview --> Replay : Fix & Reprocess\r\n        ManualReview --> Drop : Discard\r\n    }\r\n```\r\n\r\n1.  **Transient Errors** (Network glitch): We NACK with `requeue=true` (or use a delayed exchange).\r\n2.  **Permanent Errors** (Buggy code): After 5 retries, RabbitMQ moves the message to `dlq.payment.notification`.\r\n3.  **Human Intervention**: A developer inspects the DLQ, patches the bug, and uses a \"Shovel\" script to replay the messages.\r\n\r\n## Conclusion\r\n\r\nMoving to an Event-Driven architecture introduces infrastructure complexity (managing a Broker), but it buys you **Resilience** and **Decoupling**.\r\n\r\n- **Reliability**: A downstream service outage never affects the core business transaction.\r\n- **Observability**: The queue depth becomes a metric for system load.\r\n- **Extensibility**: Features can be added by simply \"listening\" to the stream of events.\r\n\r\nFor a mission-critical platform handling real money and user access, this architectural rigor is not optional—it's essential.\r\n",
    "excerpt": "In a monolithic application, consistent data is easy: you wrap everything in a single database transaction. BEGIN, Insert A, Insert B, COMMIT. Done.\r \r In a Dis...",
    "headings": []
  },
  {
    "slug": "enhanced-mdx-features",
    "frontmatter": {
      "title": "MDX Features: Rich Content Rendering",
      "description": "Exploring advanced MDX rendering capabilities with quotes, images, callouts, and interactive elements",
      "date": "2024-11-08",
      "category": "Development",
      "tags": [
        "MDX",
        "React",
        "Frontend",
        "Content"
      ],
      "author": "Khairil Rahman",
      "readTime": "8 min read",
      "published": true
    },
    "content": "\r\nWelcome to this comprehensive showcase of MDX rendering capabilities. This article demonstrates various rich content elements that make your blog posts more engaging and visually appealing.\r\n\r\nMDX (Markdown + JSX) is a powerful format that combines the simplicity of Markdown with the power of React components. This comprehensive guide showcases various rich content elements you can use in your blog posts.\r\n\r\n## Blockquotes with Author Attribution\r\n\r\nBlockquotes can now include author attribution. Simply add `-- Author Name` at the end of your blockquote:\r\n\r\n> The best way to predict the future is to create it.\r\n> -- Peter Drucker\r\n\r\n> Innovation distinguishes between a leader and a follower.\r\n> -- Steve Jobs\r\n\r\n## Enhanced Images with Captions\r\n\r\nImages now support captions using the `title` attribute in markdown:\r\n\r\n![Beautiful sunset over mountains](https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=400&fit=crop \"A stunning sunset view over rugged mountain peaks\")\r\n\r\n## Callout Boxes\r\n\r\nUse callout boxes to highlight important information:\r\n\r\n### Info Callout\r\n\r\n<div class=\"callout-info\">\r\n  Info: This is useful for general information that readers should pay attention\r\n  to.\r\n</div>\r\n\r\n### Warning Callout\r\n\r\n<div class=\"callout-warning\">\r\n  Warning: Be careful with this important warning message.\r\n</div>\r\n\r\n### Success Callout\r\n\r\n<div class=\"callout-success\">\r\n  Success: Great job! This indicates successful completion of a task.\r\n</div>\r\n\r\n### Error Callout\r\n\r\n<div class=\"callout-error\">\r\n  Error: Something went wrong. Check your code and try again.\r\n</div>\r\n\r\n## Collapsible Sections\r\n\r\nCreate expandable content sections for better organization:\r\n\r\n<details>\r\n<summary>What is MDX?</summary>\r\n\r\nMDX is a format that allows you to write JSX in your Markdown documents. It combines the simplicity of Markdown with the power of React components, enabling you to create rich, interactive content.\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>How does it work?</summary>\r\n\r\nMDX files are processed by remark and rehype plugins that transform the content into React components. This allows you to use custom components directly in your markdown while maintaining readability.\r\n\r\n</details>\r\n\r\n## Text Formatting\r\n\r\n### Highlighted Text\r\n\r\nUse the `<mark>` tag to highlight important text:\r\n\r\nThe `<mark>` element represents text which is <mark>marked or highlighted</mark> for reference or notation purposes.\r\n\r\n### Code Blocks with Copy Functionality\r\n\r\nCode blocks now include syntax highlighting and copy-to-clipboard functionality:\r\n\r\n```javascript\r\nfunction greetUser(name) {\r\n  console.log(`Hello, ${name}! Welcome to MDX rendering.`);\r\n  return `Greeting sent to ${name}`;\r\n}\r\n\r\n// Usage\r\ngreetUser(\"Developer\");\r\n```\r\n\r\n```python\r\ndef calculate_fibonacci(n):\r\n    \"\"\"Calculate the nth Fibonacci number\"\"\"\r\n    if n <= 1:\r\n        return n\r\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\r\n\r\n# Example usage\r\nprint(calculate_fibonacci(10))  ## Output: 55\r\n```\r\n\r\n### Advanced Lists\r\n\r\n- **Feature 1:** Enhanced list styling with custom bullets\r\n- **Feature 2:** Better spacing and typography\r\n- **Feature 3:** Improved readability across devices\r\n\r\n## Mathematical Expressions\r\n\r\nWhile not natively supported in this renderer, you can use inline code for simple expressions: `E = mc²` or `a² + b² = c²`.\r\n\r\n## Mermaid Diagrams\r\n\r\nMermaid diagrams are now supported! You can create various types of diagrams directly in your MDX content using the `mermaid` language syntax.\r\n\r\n### Flowchart Example\r\n\r\n```mermaid\r\nflowchart TD\r\n    A[Start] --> B{Is it working?}\r\n    B -->|Yes| C[Great!]\r\n    B -->|No| D[Debug]\r\n    D --> B\r\n    C --> E[End]\r\n```\r\n\r\n### Sequence Diagram Example\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User\r\n    participant Frontend\r\n    participant API\r\n    participant Database\r\n    \r\n    User->>Frontend: Submit form\r\n    Frontend->>API: POST /api/users\r\n    API->>Database: Insert user data\r\n    Database-->>API: Confirmation\r\n    API-->>Frontend: 201 Created\r\n    Frontend-->>User: Success message\r\n```\r\n\r\n### Class Diagram Example\r\n\r\n```mermaid\r\nclassDiagram\r\n    class User {\r\n        +string id\r\n        +string email\r\n        +string name\r\n        +login() bool\r\n        +logout() void\r\n    }\r\n    \r\n    class Post {\r\n        +string id\r\n        +string title\r\n        +string content\r\n        +datetime createdAt\r\n        +publish() void\r\n    }\r\n```\r\n\r\n### State Diagram Example\r\n\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> Idle\r\n    Idle --> Loading: Start request\r\n    Loading --> Success: Data received\r\n    Loading --> Error: Request failed\r\n    Success --> [*]\r\n    Error --> Idle: Retry\r\n```\r\n\r\n## Tables with Enhanced Styling\r\n\r\n| Feature     | Status   | Description                    |\r\n| ----------- | -------- | ------------------------------ |\r\n| Blockquotes | Enhanced | Now support author attribution |\r\n| Images      | Enhanced | Added caption support          |\r\n| Callouts    | New      | Multiple types available       |\r\n| Collapsible | New      | Expandable content sections    |\r\n| Highlights  | New      | Text highlighting support      |\r\n\r\n## Conclusion\r\n\r\nThese MDX features provide a rich set of tools for creating engaging and interactive blog content. From author-attributed quotes to collapsible sections, callout boxes, and now **Mermaid diagrams**, your articles can now be more visually appealing and user-friendly.\r\n\r\nMermaid diagrams support various types including:\r\n- Flowcharts for process visualization\r\n- Sequence diagrams for interaction flows\r\n- Class diagrams for system architecture\r\n- State diagrams for state management\r\n- And many more diagram types!\r\n\r\n> The future of web content is interactive and engaging. With MDX rendering, we're just scratching the surface of what's possible.\r\n> -- Modern Web Developer\r\n\r\n_This article showcases the MDX renderer capabilities, including the new Mermaid diagram support. Try creating your own content with these features!_\r\n",
    "excerpt": "Welcome to this comprehensive showcase of MDX rendering capabilities. This article demonstrates various rich content elements that make your blog posts more eng...",
    "headings": []
  }
] as Article[],
  categories: [
  {
    "name": "Development",
    "slug": "development",
    "description": "Development related articles",
    "count": 1
  },
  {
    "name": "Backend Engineering",
    "slug": "backend-engineering",
    "description": "Backend Engineering related articles",
    "count": 1
  }
] as Category[],
  tags: [
  "Content",
  "Event-Driven",
  "Frontend",
  "MDX",
  "Microservices",
  "RabbitMQ",
  "React",
  "Reliability",
  "System Design"
] as string[],
  lastUpdated: '2026-01-07T08:05:51.162Z',
} as const;

// Helper functions
export function getAllArticles(): Article[] {
  return blogData.articles;
}

export function getArticleBySlug(slug: string): Article | undefined {
  return blogData.articles.find(article => article.slug === slug);
}

export function getArticlesByCategory(categorySlug: string): Article[] {
  return blogData.articles.filter(article => 
    article.frontmatter.category.toLowerCase().replace(/s+/g, '-') === categorySlug
  );
}

export function getAllCategories(): Category[] {
  return blogData.categories;
}

export function getRelatedArticles(currentArticle: Article, limit: number = 3): Article[] {
  return blogData.articles
    .filter(article => 
      article.slug !== currentArticle.slug &&
      (
        article.frontmatter.category === currentArticle.frontmatter.category ||
        article.frontmatter.tags.some(tag => currentArticle.frontmatter.tags.includes(tag))
      )
    )
    .slice(0, limit);
}

export function searchArticles(query: string): Article[] {
  const searchTerm = query.toLowerCase();
  return blogData.articles.filter(article =>
    article.frontmatter.title.toLowerCase().includes(searchTerm) ||
    article.frontmatter.description.toLowerCase().includes(searchTerm) ||
    article.frontmatter.tags.some(tag => tag.toLowerCase().includes(searchTerm))
  );
}

export function getRecentArticles(limit: number = 5): Article[] {
  return blogData.articles.slice(0, limit);
}
